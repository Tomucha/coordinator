package cz.clovekvtisni.coordinator.android.util;import java.text.CharacterIterator;import java.text.SimpleDateFormat;import java.text.StringCharacterIterator;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.TimeZone;/** * Provides ISO8601 date-time processing utilities * * @author Simeon Simeonov (simeons@allaire.com) * @version 1.0 */public class ISO8601{    @SuppressWarnings({"ConstantConditions"})    public static Date parseDate(String dateString)    {        // Start with some believable defaults        try        {            StringCharacterIterator it = new StringCharacterIterator(dateString);            IntegerParser ip = new IntegerParser(it, 10);            int year = ip.parseInt(4, 4, '-');            it.next();            int month = ip.parseInt(1, 2, '-');            it.next();            int day = ip.parseInt(1, 2, 'T');            it.next();            int hours = ip.parseInt(1, 2, ':');            it.next();            int minutes = ip.parseInt(1, 2, ':');            it.next();            int seconds = ip.parseInt(1, 2);            boolean bHasOffset = false;            int nRawTimezoneOffset = 0;            char charOffset = it.current();            if (charOffset != CharacterIterator.DONE)            {                if (charOffset != '+' && charOffset != '-')                {                    // Error: bad timezone character                    return null;                }                bHasOffset = true;                it.next();                final int tz = ip.parseInt(1, 4, false, ':');                if (it.current() == ':') {                    nRawTimezoneOffset = 60 * tz;                    it.next();                    nRawTimezoneOffset = 60 * 1000 * (nRawTimezoneOffset + ip.parseInt(1, 2));                }                else if (it.current()  == CharacterIterator.DONE) {                    nRawTimezoneOffset = 60 * (tz / 100);                    nRawTimezoneOffset = 60 * 1000 * (nRawTimezoneOffset + tz % 100);                }                else {                    return null;                }                if (charOffset == '-')                {                    nRawTimezoneOffset *= -1;                }                if (it.current() != CharacterIterator.DONE)                {                    // Error: garbage at end                    return null;                }            }            // Get current timezone offset            // __SIM: need DST adjustment!            int nCurrentTimezoneOffset = TimeZone.getDefault().getRawOffset();            // Calculate net timezone offset            int nNetTimezoneOffset = nCurrentTimezoneOffset - nRawTimezoneOffset;            GregorianCalendar gc = new GregorianCalendar(year, month - 1, day, hours, minutes, seconds);            if (bHasOffset) {                //HACK, toto sa ma spravne nastavovat vzdy, ale 4PAP nam vracia lokalny cas bez uvedenej timezony                gc.add(Calendar.MILLISECOND, nNetTimezoneOffset);            }            return gc.getTime();        } catch (Exception e) {            return null;        }    }    public static SimpleDateFormat ISO8601FORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");    public static String formatDate(Date date) {        return ISO8601FORMAT.format(date);    }    public static class IntegerParserException extends Exception {    }    private static class IntegerParser {        private CharacterIterator m_it;        private int m_radix;        private IntegerParser() {        }        public IntegerParser(CharacterIterator it, int radix)        {            m_it = it;            m_radix = radix;        }        public int parseInt(int minLength, int maxLength) throws IntegerParserException        {            return parseInt(minLength, maxLength, false, '\0');        }        public int parseInt(int minLength, int maxLength, char chTerminator) throws IntegerParserException        {            return parseInt(minLength, maxLength, true, chTerminator);        }        public int parseInt(int minLength, int maxLength, boolean bCheckTerminator, char chTerminator) throws IntegerParserException        {            int nValue = 0;            int nLen = 0;            char c = m_it.current();            while (c != CharacterIterator.DONE)            {                // Get the current digit                int nDigit = Character.digit(c, m_radix);                if (nDigit == -1) break;                // Update value                nValue = m_radix * nValue + nDigit;                // Advance                m_it.next();                c = m_it.current();                ++nLen;            }            if (nLen < minLength || maxLength < nLen || (bCheckTerminator && c != chTerminator))            {                // String too short, bad character was seen, or                // string is too long, or                // the terminating character is not valid                throw new IntegerParserException();            }            else {                return nValue;            }        }    }}